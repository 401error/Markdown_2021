### Redis 单线程模型

* redis采用reactor模式设计了自己的事件处理流程，reactor也就是事件驱动模型，指的是不知道事件何时发生，只有事件发生再调用相关的事件处理函数
*  **I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**
  * 也就是靠一个线程来监听客户端，当数据就绪时（因为socket.accept()，当数据没有到来时，线程是阻塞的)，再唤醒相应的事件处理器，进行处理





### Redis 数据结构

![redis过期时间](C:\Users\ZHW\Desktop\笔记\IMG\redis过期时间.png)

* redis也是数据库，然后dict存所有的键值对，
* ==expires==存储所有的设置了过期时间的数据，也是一个hash，key是过期键值对的key，value是过期的时间。



### Redis 提供 6 种数据淘汰策略：

1. **volatile-lru（least recently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！



### 缓存穿透

* 大量数据缓存里没有，直接打数据库，这样的key一般是不存在的
* 解决方法==布隆过滤器==（判断海量数据是否存在一个某一数据）
  * 位数组，多个哈希函数，每个bit位，1表示存在，0表示不存在，通过多个hash，然后把key填入bit数组
  * 虽然存在误判，但不存在，就一定不存在
  * 缺点：理论情况下添加到集合中的元素越多，误报的可能性就越大





* 雪崩，redis里的数据都失效类，全打到数据库里
* 击穿，某个KEY-VALUE失效了，然后很多人访问这会KEY，就全打到了数据库里




### Redis持久化

**快照（snapshotting）持久化（RDB）**

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。