# JVM内存模型

* 每个线程有自己的工作内存，除此之外还有主内存区域，对变量的读写不一定会及时写入到主存，想要对其它线程可见，需要将工作内存中的写入同步到主存，并且同步到各个线程的工作内存中。

  ![222.png](C:\Users\ZHW\Desktop\笔记\IMG\1240)



* 实现可见性，使用Volatile.











# JVM内存结构

* 栈
* 堆
* 方法区（**JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配**，移除的原因在于永久代会因为类的加载过多而溢出）
* 本地方法栈
* 程序计数器
* 堆和方法区线程共享，其他都是线程私有



## 栈



* 栈是存放方法的引用，对象的引用，以及八大基本类型（int,float,double,short,long,boolean,char,bite)

* 栈帧 ：存的是被压入栈的方法， 栈帧存储了方法的==局部变量表==、==操作数栈==、==动态连接==和==方法返回地址==等信息 







## 方法区



方法区存放

* static 静态变量 
* final 常量
* class  类信息
* 常量池 字符串常量



方法区的实现：永久代和元空间

* 所谓永久代和元空间是不同jvm虚拟机的实现，在Hotspot里面才有这样的说法

* 在本质上永久代和元空间是没有区别，都实现了方法区

* 区别在于，永久代是jdk8以前在用，是放在堆里面的，1.8以后使用了元空间，但字符串常量池和静态变量引用还是依旧在堆里，其他都使用了==物理内存==
* 使用元空间是为了让内存不那么容易溢出



　　

## 堆



堆存放真正的对象

堆分三个区

* 新生区

  * 新生区又分三个区，eden区，幸存者to区，幸存者from区

      * 新进来的对象会放到eden区，当满了之后，会触发一次，轻gc，把没有被回收的放入幸存者，幸存者区经过15次GC，还没被回收，就放入老年区

* 老年区

  * 老年区满了，触发一次重GC

    

* 永久区



# 特殊的字符串

　　字符串是一个特殊包装类

* 其引用是存放在栈里的,而对象内容必须根据创建方式不同定(常量池和堆).有的是编译期就已经创建好，存放在字符串常 量池中，而有的是运行时才被创建.使用new关键字，存放在堆中。

  * 对象内容在字符常量池里

    ```java
    String a ="sdsds";
    //"sdsds"会放进常量池里；并且a会指向在这个地址
    ```

  * 对象内容在堆里

    ```java
    Strng a= new String();
    //a被new出来，就存到堆里
    ```

    

* string对象一旦被创建，就无法更改其内容，但所谓的更改函数 都是创建了新的String对象 

